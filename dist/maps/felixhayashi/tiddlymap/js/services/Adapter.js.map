{"version":3,"sources":["felixhayashi/tiddlymap/js/services/Adapter.js"],"names":["env","Adapter","tracker","edgeTypeSubscriberRegistry","getTiddlerById","bind","getId","getIdByTiddler","assignId","indeces","$tm","wiki","$tw","visShapesWithTextInside","utils","getLookupTable","edge","_processEdge","edges","convert","i","length","deleteEdge","action","logger","fromTRef","from","tiddlerExists","tObj","getTiddler","type","allETy","EdgeType","getInstance","handlers","getAllForType","fn","exists","save","groupBy","opts","start","tRefs","getMatches","selector","allPotentialNodes","getEdgesForSet","toWL","typeWL","adjList","groupByProperty","stop","matches","addProperties","steps","visited","getArrayValuesAsHashmapKeys","view","ViewAbstraction","allEdgesLeadingToNeighbours","makeHashMap","allNeighbours","maxSteps","parseInt","direction","getConfig","isWalkBoth","isWalkIn","isWalkOut","neighFilter","getNodeFilter","getAdjacencyList","addAsNeighbour","role","neighboursOfThisStep","id","tRef","isTrue","config","sys","nodeFilterNeighbours","isMatch","node","makeNode","push","step","isSystemOrDraft","outgoing","getEdges","t","toArrow","invertedArrow","incoming","j","neighbourhood","nodes","filter","edgeTypeWL","neighbourhoodScope","neighScope","getEdgeTypeFilter","graph","selectNodesByReferences","outputType","neighbours","getNeighbours","group","Object","assign","isEnabled","nodeTRefs","getTiddlersByIds","removeObsoleteViewData","attachStylesToNodes","tiddler","eTySubscribers","getAll","l","loadEdges","to","addStyleToEdge","tiddlers","getAllPotentialNodes","newName","selectEdgesByType","deleteTiddler","fullPath","result","keys","nodeIds","options","selectNodesByIds","NodeType","protoNode","merge","fields","title","label","field","nodeLabel","renderText","replace","src","protoByTRef","glNTy","inheritors","getInheritors","proto","style","inheritedStyles","getInheritedNodeStyles","viewNodeData","getNodeData","isStaticMode","icon","inheritedStyle","getIcon","color","parseJSON","nodeData","fixed","x","y","isColorObject","background","border","undefined","addNodeIcon","font","shape","glNTyById","deleteTiddlers","viewRefs","allViews","removeNode","deleteEdges","ids","deleteNode","protoTiddler","generateNewTitle","getRandomLabel","Tiddler","text","getModificationFields","getCreationFields","addTiddler","addNode","Array","isArray","vis","DataSet","getFAdigits","str","substr","fa","face","code","String","fromCharCode","size","tw","imgTObj","image","getDataUri","data","obsoleteDataItems","getLabel","saveNodeData","faIcon","twIcon"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/services/Adapter.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Adapter\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport ViewAbstraction              from '$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction';\nimport EdgeType                     from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport NodeType                     from '$:/plugins/felixhayashi/tiddlymap/js/NodeType';\nimport utils                        from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport Edge                         from '$:/plugins/felixhayashi/tiddlymap/js/Edge';\nimport vis                          from '$:/plugins/felixhayashi/vis/vis.js';\nimport * as env                     from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\nimport { run as getContrastColour } from '$:/core/modules/macros/contrastcolour.js';\n\n/***************************** CODE ********************************/\n\n/**\n * This library acts as an abstraction layer above the tiddlywiki\n * system. All the provided methods give the api-user the chance\n * to interact with tiddlywiki as if it was a simple graph database.\n *\n * Everything that is related to retrieving or inserting nodes and\n * edges is handled by the adapter class.\n *\n * You don't need to create your own instance of this class.\n * The adapter service may be accessed from anywhere using\n * `$tm.apapter`.\n *\n * @constructor\n */\nclass Adapter {\n\n  /**\n   * @param {Tracker} tracker\n   * @param {EdgeTypeSubscriberRegistry} edgeTypeSubscriberRegistry\n   */\n  constructor(tracker, edgeTypeSubscriberRegistry) {\n\n    this.getTiddlerById = tracker.getTiddlerById.bind(tracker);\n    this.getId = tracker.getIdByTiddler.bind(tracker);\n    this.assignId = tracker.assignId.bind(tracker);\n\n    this.edgeTypeSubscriberRegistry = edgeTypeSubscriberRegistry;\n\n    this.indeces = $tm.indeces;\n    this.wiki = $tw.wiki;\n\n    this.visShapesWithTextInside = utils.getLookupTable([\n      'ellipse', 'circle', 'database', 'box', 'text'\n    ]);\n\n  }\n\n  /**\n   * This function will delete the specified edge object from the system.\n   *\n   * @param {Edge} edge - The edge to be deleted. The edge necessarily\n   *     needs to possess an `id` and a `from` property.\n   * @return {Edge} The deleted edge is returned.\n   */\n  deleteEdge(edge) {\n\n    return this._processEdge(edge, 'delete');\n\n  }\n\n  /**\n   * Persists an edge by storing the vector (from, to, type).\n   *\n   * @param {Edge} edge - The edge to be saved. The edge necessarily\n   *     needs to possess a `to` and a `from` property.\n   * @return {Edge} The newly inserted edge.\n   */\n  insertEdge(edge) {\n\n    return this._processEdge(edge, 'insert');\n\n  }\n\n  /**\n   * Removes multiple edges from several stores.\n   *\n   * @param {EdgeCollection} edges - The edges to be deleted.\n   */\n  deleteEdges(edges) {\n\n    edges = utils.convert(edges, 'array');\n    for (let i = edges.length; i--;) {\n      this.deleteEdge(edges[i]);\n    }\n\n  }\n\n  /**\n   * Private function to handle the insertion or deletion of an edge.\n   * It prepares the process according to the action type and delegates\n   * the task to more specific functions.\n   *\n   * @private\n   * @return {Edge} The processed edge.\n   */\n  _processEdge(edge, action) {\n\n    $tm.logger('debug', 'Edge', action, edge);\n\n    // get from-node and corresponding tiddler\n    const fromTRef = this.getTiddlerById(edge.from);\n\n    if (!fromTRef || !utils.tiddlerExists(fromTRef)) {\n      return;\n    }\n\n    const tObj = utils.getTiddler(fromTRef);\n    const type = this.indeces.allETy[edge.type] || EdgeType.getInstance(edge.type);\n    const handlers = this.edgeTypeSubscriberRegistry.getAllForType(type);\n    const fn = `${action}Edge`;\n\n    for (let i = handlers.length; i--;) {\n      (handlers[i][fn])(tObj, edge, type);\n    }\n\n    // if type didn't exist yet, create it\n    if (action === 'insert' && !type.exists()) {\n      type.save();\n    }\n\n    return edge;\n\n  }\n\n  /**\n   * This function will return an adjacency list for the nodes\n   * present in the current system. The list may be restricted by\n   * optional filters.\n   *\n   * @param {string} [groupBy='to'] - Specifies by which property the\n   *     adjacency list is indexed. May be either 'from' or 'to'.\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edge-types are included.\n   * @param {Hashmap} [opts.edges] - A set of edges on which basis\n   *     the adjacency list is build. If not provided,\n   *     all edges in the system are considered.\n   * @return {Object<Id, Array<Edge>>} For each key (a node id) an\n   *     array of edges pointing 'from' (or 'to'; depends on `groupBy`)\n   *     is supplied as value.\n   */\n  getAdjacencyList(groupBy, opts = {}) {\n\n    $tm.start('Creating adjacency list');\n\n    if (!opts.edges) {\n      const tRefs = utils.getMatches(env.selector.allPotentialNodes);\n      opts.edges = this.getEdgesForSet(tRefs, opts.toWL, opts.typeWL);\n    }\n\n    const adjList = utils.groupByProperty(opts.edges, groupBy || 'to');\n\n    $tm.stop('Creating adjacency list');\n\n    return adjList;\n\n  }\n\n  /**\n   * This function will return all neighbours of a graph denoted by\n   * a set of tiddlers.\n   *\n   * @todo parts of this code may be outsourced into a function to\n   * prevent repeating code.\n   *\n   * @param {Array<TiddlerReference>} matches - The original set that\n   *     defines the starting point for the neighbourhood discovery\n   * @param {Hashmap} [opts] - An optional options object.\n   * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n   *    that restricts which edges are travelled to reach a neighbour.\n   * @param {Hashmap} [opts.edges] - An initial set of edges that is\n   *    used in the first step to reach immediate neighbours, if no\n   *    set of edges is specified, all exsisting edges will be considered.\n   * @param {number} [opts.steps] - An integer value that specifies\n   *    the scope of the neighbourhood. A node is considered a neighbour\n   *    if it can be reached within the given number of steps starting\n   *    from original set of tiddlers returned by the node filter.\n   * @param {Hashmap} [opts.addProperties] - a hashmap\n   *     containing properties to be added to each node.\n   *     For example:\n   *     {\n   *       group: 'g1',\n   *       color: 'red'\n   *     }\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all neighbouring nodes* },\n   *       edges: { *all edges connected to neighbours* },\n   *     }\n   */\n  getNeighbours(matches, opts = {}) {\n\n    $tm.start('Get neighbours');\n\n    const { addProperties, toWL, typeWL, steps } = opts;\n    const { allETy } = this.indeces;\n\n    // index of all tiddlers have already are been visited, either by\n    // having been included in the original set, or by having been\n    // recorded as neighbour during the discovery.\n    const visited = utils.getArrayValuesAsHashmapKeys(matches);\n    const view = ViewAbstraction.exists(opts.view) ? new ViewAbstraction(opts.view) : null;\n    const allEdgesLeadingToNeighbours = utils.makeHashMap();\n    const allNeighbours = utils.makeHashMap();\n    const maxSteps = (parseInt(steps) > 0 ? steps : 1);\n    const direction = (opts.direction || (view && view.getConfig('neighbourhood_directions')));\n    const isWalkBoth = (!direction || direction === 'both');\n    const isWalkIn = (isWalkBoth || direction === 'in');\n    const isWalkOut = (isWalkBoth || direction === 'out');\n\n    // in order to apply the node-filter also to neighbours we need to make it\n    // include all tiddlers in the filter's source (e.g. a tiddler and a few neighbours)\n    // and then apply the filter – which now has the chance to take away tiddlers\n    // a few filters from the set\n    const neighFilter = view && `[all[]] ${view.getNodeFilter('raw')}`;\n\n    // adjacency receives whitelists through opts\n    const adjList = this.getAdjacencyList('to', opts);\n\n    const addAsNeighbour = (edge, role, neighboursOfThisStep) => {\n      allEdgesLeadingToNeighbours[edge.id] = edge;\n      const tRef = this.getTiddlerById(edge[role]);\n\n      if (\n        view\n        && utils.isTrue($tm.config.sys.nodeFilterNeighbours)\n        && !utils.isMatch(tRef, neighFilter)) {\n        return;\n      }\n\n      if (!visited[tRef]) {\n        visited[tRef] = true;\n        const node = this.makeNode(tRef, addProperties);\n        if (node) { // saveguard against obsolete edges or other problems\n          // record node\n          allNeighbours[node.id] = node;\n          neighboursOfThisStep.push(tRef);\n        }\n      }\n    };\n\n    // needed later\n    let step;\n\n    // loop if still steps to be taken and we have a non-empty starting set\n    for (step = 0; step < maxSteps && matches.length; step++) {\n\n      // neighbours that are discovered in the current step;\n      // starting off from the current set of matches;\n      const neighboursOfThisStep = [];\n\n      // loop over all nodes in the original set\n      for (let i = matches.length; i--;) {\n\n        if (utils.isSystemOrDraft(matches[i])) {\n          // = this might happen if the user manually created edges\n          // that link to a system/draft tiddler or if the original\n          // set contained system/draft tiddlers.\n          continue;\n        }\n\n        // get all outgoing edges\n        // = edges originating from the starting set and point outwards\n        const outgoing = this.getEdges(matches[i], toWL, typeWL);\n        for (let id in outgoing) {\n\n          const t = allETy[outgoing[id].type];\n          if (isWalkBoth || isWalkOut && t.toArrow || isWalkIn && t.invertedArrow) {\n\n            addAsNeighbour(outgoing[id], 'to', neighboursOfThisStep);\n          }\n        }\n\n        // get all incoming edges\n        // = edges originating from outside pointing to the starting set\n        const incoming = adjList[this.getId(matches[i])];\n        if (!incoming) {\n          continue;\n        }\n\n        for (let j = incoming.length; j--;) {\n          const t = allETy[incoming[j].type];\n          if (isWalkBoth || isWalkIn && t.toArrow || isWalkOut && t.invertedArrow) {\n            addAsNeighbour(incoming[j], 'from', neighboursOfThisStep);\n          }\n        }\n      }\n\n      // the current set of newly discovered neighbours forms the\n      // starting point for the next discovery\n      matches = neighboursOfThisStep;\n\n    }\n\n    const neighbourhood = {\n      nodes: allNeighbours,\n      edges: allEdgesLeadingToNeighbours\n    };\n\n    $tm.logger('debug', 'Retrieved neighbourhood', neighbourhood, 'steps', step);\n\n    $tm.stop('Get neighbours');\n\n    return neighbourhood;\n\n  }\n\n  /**\n   * This function will assemble a graph object based on the supplied\n   * node and edge filters. Optionally, a neighbourhood may be\n   * merged into the graph neighbourhood.\n   *\n   * @param {string|ViewAbstraction} [view] - The view in which\n   *     the graph will be displayed.\n   * @param {string|ViewAbstraction} [filter] - If supplied,\n   *     this will act as node filter that defines which nodes\n   *     are to be displayed in the graph; a possible view node filter\n   *     would be ignored.\n   * @param {Hashmap} [edgeTypeWL] - A whitelist lookup-table\n   *     that restricts which edges are travelled to reach a neighbour.\n   * @param {number} [neighbourhoodScope] - An integer value that\n   *     specifies the scope of the neighbourhood in steps.\n   *     See {@link Adapter#getNeighbours}\n   * @return {Object} An object of the form:\n   *     {\n   *       nodes: { *all nodes in the graph* },\n   *       edges: { *all edges in the graph* },\n   *     }\n   *     Neighbours will be receive the 'tmap:neighbour' type.\n   */\n  getGraph({ view, filter, edgeTypeWL, neighbourhoodScope } = {}) {\n\n    $tm.start('Assembling Graph');\n\n    view = ViewAbstraction.exists(view) ? new ViewAbstraction(view) : null;\n    const matches = utils.getMatches(filter || (view && view.getNodeFilter('compiled')));\n    const neighScope = parseInt(neighbourhoodScope || (view && view.getConfig('neighbourhood_scope')));\n    const typeWL = (edgeTypeWL || (view && view.getEdgeTypeFilter('whitelist')));\n    const toWL = utils.getArrayValuesAsHashmapKeys(matches);\n\n    const graph = {\n      edges: this.getEdgesForSet(matches, toWL, typeWL),\n      nodes: this.selectNodesByReferences(matches, {\n        view: view,\n        outputType: 'hashmap'\n      })\n    };\n\n    if (neighScope) {\n      const neighbours = this.getNeighbours(matches, {\n        steps: neighScope,\n        view: view,\n        typeWL: typeWL,\n        addProperties: {\n          group: 'tmap:neighbour'\n        }\n      });\n\n      // add neighbours (nodes and edges) to graph\n      Object.assign(graph.nodes, neighbours.nodes);\n      Object.assign(graph.edges, neighbours.edges);\n\n      if (view && view.isEnabled('show_inter_neighbour_edges')) {\n        const nodeTRefs = this.getTiddlersByIds(neighbours.nodes);\n        // this time we need a whitelist based on the nodeTRefs\n        const toWL = utils.getArrayValuesAsHashmapKeys(nodeTRefs);\n        Object.assign(graph.edges, this.getEdgesForSet(nodeTRefs, toWL));\n      }\n    }\n\n    // this is pure maintainance!\n    removeObsoleteViewData(graph.nodes, view);\n\n    // add styles to nodes\n    this.attachStylesToNodes(graph.nodes, view);\n\n    $tm.stop('Assembling Graph');\n\n    $tm.logger('debug', 'Assembled graph:', graph);\n\n    return graph;\n\n  }\n\n  /**\n   * Returns all edges stored in a given tiddler. Any edge stored in a\n   * tiddler is orginally an outgoing edge. Depending on how the user\n   * changes the arrow head (by manipulating the Visjs edge-type style),\n   * the edge may change its orientation and become an incoming edge or\n   * bi-directional. Therefore, the edges retrieved may be incoming,\n   * outgoing or both!\n   *\n   * Returned edges may be of the following type:\n   *\n   * - Edges stored in the tiddler text (=links).\n   * - Edges stored in fields denoted by magic edge-types.\n   * - TiddlyMap edges stored in a json format\n   *\n   * @param {Tiddler} tiddler - A tiddler reference or object from\n   *     which to retrieve the edges.\n   * @param {Hashmap<TiddlerReference, boolean>} [toWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge that leads to a certain tiddler in the result or not.\n   *     In this case, all edges stored in the tiddler are treated as\n   *     outgoing and the arrow head is ignored. If not specified,\n   *     all edges are included.\n   * @param {Hashmap<string, boolean>} [typeWL]\n   *     A hashmap on which basis it is decided, whether to include\n   *     an edge of a given type in the result or not. If not\n   *     specified, all edges are included.\n   */\n  getEdges(tiddler, toWL, typeWL) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) {\n      return;\n    }\n\n    const { allETy } = this.indeces;\n    const edges = utils.makeHashMap();\n    const eTySubscribers = this.edgeTypeSubscriberRegistry.getAll();\n\n    for (let i = 0, l = eTySubscribers.length; i < l; i++) {\n      Object.assign(edges, (eTySubscribers[i]).loadEdges(tObj, toWL, typeWL));\n    }\n\n    for (let id in edges) {\n\n      const edge = edges[id];\n\n      // check exists for historical reasons...\n      if (!edge.from || !edge.to) {\n        continue;\n      }\n\n      const type = allETy[edge.type] || EdgeType.getInstance(edge.type);\n      addStyleToEdge(edges[id], type);\n\n      edges[id] = edge;\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * The method will return all outgoing edges for a subset of tiddlers.\n   *\n   * @param {Array<Tiddler>} tiddlers - The set of tiddlers to consider.\n   * @param toWL\n   * @param typeWL\n   * @return {Hashmap<Id, Edge>} An edge collection.\n   */\n  getEdgesForSet(tiddlers, toWL, typeWL) {\n\n    const edges = utils.makeHashMap();\n    for (let i = tiddlers.length; i--;) {\n      Object.assign(edges, this.getEdges(tiddlers[i], toWL, typeWL));\n    }\n\n    return edges;\n\n  }\n\n  /**\n   * Select all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   */\n  selectEdgesByType(type) {\n\n    const typeWL = utils.makeHashMap({\n      [EdgeType.getInstance(type).id]: true,\n    });\n\n    return this.getEdgesForSet(this.getAllPotentialNodes(), null, typeWL);\n\n  }\n\n  /**\n   *\n   * @return {*}\n   */\n  getAllPotentialNodes() {\n\n    return utils.getMatches($tm.selector.allPotentialNodes);\n\n  };\n\n  /**\n   * Deletes or renames all edges of a given type.\n   *\n   * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n   * @param {('rename'|'delete')} [action='delete']\n   * @param {string} [newName]\n   */\n  _processEdgesWithType(type, { action, newName }) {\n\n    type = EdgeType.getInstance(type);\n\n    $tm.logger('debug', 'Processing edges', type, action);\n\n    // get edges\n    const edges = this.selectEdgesByType(type);\n\n    if (action === 'rename') {\n\n      // clone type first to prevent auto-creation\n      (new EdgeType(newName, type)).save();\n\n    }\n\n    for (let id in edges) {\n\n      this._processEdge(edges[id], 'delete');\n\n      if (action === 'rename') {\n        edges[id].type = newName;\n        this._processEdge(edges[id], 'insert');\n      }\n    }\n\n    // finally remove the old type\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Returns a set of nodes that corresponds to a set of tiddlers.\n   *\n   * @param {TiddlerCollection} tiddlers - A collection of tiddlers.\n   * @param {Hashmap} [addProperties] - a hashmap\n   * @param {CollectionTypeString} [outputType='dataset'] - The result type.\n   *\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByReferences(tiddlers, { addProperties, outputType } = {}) {\n\n    const result = utils.makeHashMap();\n    const keys = Object.keys(tiddlers);\n\n    for (let i = keys.length; i--;) {\n\n      const node = this.makeNode(tiddlers[keys[i]], addProperties);\n      if (node) {\n        result[node.id] = node;\n      }\n\n    }\n\n    return utils.convert(result, outputType);\n\n  }\n\n  /**\n   * Retrieve nodes based on the a list of ids that corrspond to tiddlers\n   * id fields.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids of the tiddlers\n   *     that represent the nodes.\n   * @param {Hashmap} [options] - See {@link Adapter#selectNodesByReferences}.\n   * @return {NodeCollection} A collection of a type specified in the options.\n   */\n  selectNodesByIds(nodeIds, options) {\n\n    const tRefs = this.getTiddlersByIds(nodeIds);\n\n    return this.selectNodesByReferences(tRefs, options);\n\n  }\n\n  /**\n   * Select a single node by id.\n   *\n   * @param {Id} id - A node's id\n   * @param {Hashmap} [options]\n   *     Except from the outputType option, all options\n   *     are inherited from {@link Adapter#selectNodesByIds}.\n   * @return {Node|undefined} A node or nothing.\n   */\n  selectNodeById(id, options) {\n\n    options = Object.assign({}, options, { outputType: 'hashmap' });\n    const result = this.selectNodesByIds([ id ], options);\n\n    return result[id];\n\n  }\n\n  /**\n   * Deletes a node type from the system.\n   * @param {NodeType|string} type - the node type id or the actual NodeType\n   */\n  removeNodeType(type) {\n\n    type = NodeType.getInstance(type);\n    this.wiki.deleteTiddler(type.fullPath);\n\n  }\n\n  /**\n   * Gets a Node representation for a tiddler.\n   *\n   * @param {Tiddler} tiddler - the tiddler to represent as node\n   * @param {Object} protoNode - default node properties\n   *\n   * @return {Node|void}\n   */\n  makeNode(tiddler, protoNode) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj || utils.isSystemOrDraft(tObj)) return;\n\n    // merge(!) so later node manipulations do not affect other nodes\n    const node = utils.merge({}, protoNode);\n\n    // note: assignId() will not assign an id if the tiddler already has one\n    node.id = this.assignId(tObj);\n\n    // backreference to tiddler;\n    // https://github.com/felixhayashi/TW5-TiddlyMap/issues/304\n    node.tRef = tObj.fields.title;\n\n    // add label\n    const label = tObj.fields[$tm.field.nodeLabel];\n    node.label = (\n      label && $tm.field.nodeLabel !== 'title'\n        ? this.wiki.renderText('text/plain', 'text/vnd-tiddlywiki', label)\n        : tObj.fields.title\n    ).replace('\\\\n', '\\n');\n\n    return node;\n\n  }\n\n  /**\n   * Return node styles that are inherited from system styles or node types.\n   *\n   * @param nodes\n   * @return {Object<TiddlerReference, Object>}\n   */\n  getInheritedNodeStyles(nodes) {\n\n    const src = this.getTiddlersByIds(nodes);\n    const protoByTRef = {};\n    const glNTy = this.indeces.glNTy;\n\n    for (let i = glNTy.length; i--;) {\n      const type = glNTy[i];\n\n      let inheritors = [];\n      if (type.id === 'tmap:neighbour') { // special case\n        for (let id in nodes) {\n\n          if (nodes[id].group === 'tmap:neighbour') {\n\n            inheritors.push(this.getTiddlerById(id));\n          }\n        }\n      } else {\n        inheritors = type.getInheritors(src);\n      }\n\n      for (let j = inheritors.length; j--;) {\n        const tRef = inheritors[j];\n        const proto = protoByTRef[tRef] = (protoByTRef[tRef] || {});\n        proto.style = utils.merge(\n          proto.style || {},\n          type.style\n        );\n\n        // ATTENTION: only override proto icons when the type provides\n        // an icon since otherwise we might erase previously\n        // inherited icons.\n        if (type['fa-icon']) {\n          proto['fa-icon'] = type['fa-icon'];\n        } else if (type['tw-icon']) {\n          proto['tw-icon'] = type['tw-icon'];\n        }\n\n      }\n    }\n\n    return protoByTRef;\n\n  }\n\n  /**\n   * Adds styles to nodes.\n   *\n   * @param {Object<string, Node>} nodes\n   * @param {ViewAbstraction|string} view\n   */\n  attachStylesToNodes(nodes, view) {\n\n    view = ViewAbstraction.exists(view) ? new ViewAbstraction(view) : null;\n\n    const inheritedStyles = this.getInheritedNodeStyles(nodes);\n    const viewNodeData = view ? view.getNodeData() : utils.makeHashMap();\n    const isStaticMode = view && !view.isEnabled('physics_mode');\n\n    for (let id in nodes) {\n\n      const tRef = this.getTiddlerById(id);\n      const tObj = this.wiki.getTiddler(tRef);\n      const fields = tObj.fields;\n      const node = nodes[id];\n      let icon;\n\n      // == group styles ==\n\n      const inheritedStyle = inheritedStyles[tRef];\n\n      if (inheritedStyle) {\n\n        utils.merge(node, inheritedStyle.style);\n        icon = getIcon(inheritedStyle['fa-icon'], inheritedStyle['tw-icon']);\n      }\n\n      // == global node styles ==\n\n      // background color\n      if (fields.color) {\n        node.color = fields.color;\n      }\n\n      // global node style from vis editor\n      if (fields['tmap.style']) {\n        utils.merge(node, utils.parseJSON(fields['tmap.style']));\n      }\n\n      icon = getIcon(fields['tmap.fa-icon'], fields['icon']) || icon;\n\n      // == local node styles ==\n\n      // local node style and positions\n\n      const nodeData = viewNodeData[id];\n\n      if (nodeData) {\n\n        utils.merge(node, nodeData);\n        if (isStaticMode) {\n          // fix x if x-position is set; same for y\n          node.fixed = {\n            x: (node.x != null),\n            y: (node.y != null)\n          };\n        }\n\n        icon = getIcon(nodeData['fa-icon'], nodeData['tw-icon']) || icon;\n      }\n\n      // == tweaks ==\n\n      const isColorObject = (node.color !== null && typeof node.color === 'object');\n      // color/border-color may be undefined\n      const color = (isColorObject ? node.color.background : node.color);\n\n      node.color = {\n        background: color,\n        border: (isColorObject ? node.color.border : undefined)\n      };\n\n      // ATTENTION: this function needs to be called after color is assigned\n      addNodeIcon(node, icon);\n\n      // determine font color if not defined via a group- or node-style;\n      // in case of global and local default styles, the user is responsible\n      // him- or herself to adjust the font\n      node.font = node.font || {};\n\n      if (node.shape && !this.visShapesWithTextInside[node.shape]) {\n        node.font.color = 'black'; // force a black color\n      } else if (!node.font.color && color) {\n        node.font.color = getContrastColour(color, color, 'black', 'white');\n      }\n\n      if (node.shape === 'icon' && typeof node.icon === 'object') {\n        node.icon.color = color;\n      }\n\n    }\n\n    if (view) {\n      const node = nodes[view.getConfig('central-topic')];\n      if (node) {\n        utils.merge(node, this.indeces.glNTyById['tmap:central-topic'].style);\n      }\n    }\n\n  }\n\n  /**\n   * This function will remove all tiddlers from the wiki that correspond\n   * to a node in the collection. Drafts are also removed. The default\n   * storylist is updated eventually.\n   * call deleteNode which does the following\n   * 1. get id using IdByT\n   * 2. remove id using adapter.deleteEdgesByTo(idByT[tRef])\n   * 3. remove from all indeces\n   *\n   * @see: https://github.com/Jermolene/TiddlyWiki5/issues/1550\n   *\n   * @param {Node|string} node.\n   */\n  deleteNode(node) {\n\n    if (!node) {\n      return;\n    }\n\n    const id = (typeof node === 'object' ? node.id : node);\n    const tRef = this.getTiddlerById(id);\n\n    // delete tiddler and remove it from the river; this will\n    // automatically remove the global node style and the outgoing edges\n\n    if (tRef) {\n      // checking for tRef is needed;\n      // see: https://github.com/Jermolene/TiddlyWiki5/issues/1919\n      utils.deleteTiddlers([ tRef ]);\n    }\n\n    // delete local node-data in views containing the node\n\n    const viewRefs = utils.getMatches(env.selector.allViews);\n    for (let i = viewRefs.length; i--;) {\n      const view = new ViewAbstraction(viewRefs[i]);\n      view.removeNode(id);\n    }\n\n    // remove obsolete connected edges\n\n    const neighbours = this.getNeighbours([ tRef ]);\n    this.deleteEdges(neighbours.edges);\n\n    // -------------------------------------------\n    // NEVER DELETE AN INDEX THAT ALREADY EXISTED!\n    // -------------------------------------------\n    // Some instances may have cached the index and get confused!\n    // It does not do harm to leave indeces as is since we do not\n    // iterate over them(!) and when a tiddler has the same title or\n    // id as a deleted tiddler, which is highly unlikely, then it will\n    // simply override the index, which is totally fine. The indeces\n    // are refreshed on every boot anyway so it is not a big deal.\n    //\n    // THEREFORE:\n    //\n    // DO NOT DO delete this.tById[id];\n    // DO NOT DO delete this.idByT[tRef];\n\n  }\n\n  /**\n   * Delete all nodes from the system.\n   *\n   * @param {string[]} ids ids\n   */\n  deleteNodes(ids) {\n\n    for (let i = ids.length; i--;) {\n      this.deleteNode(ids[i]);\n    }\n\n  }\n\n  /**\n   * Create a new tiddler that gets a non-existant title and is opened\n   * for edit. If a view is registered, the fields of the tiddler match\n   * the current view. If arguments network and position are specified,\n   * the node is also inserted directly into the graph at the given\n   * position.\n   *\n   * @TODO: Description is obsolete!\n   *\n   * @param {object} node A node object to be inserted\n   * @param {ViewAbstraction|string} view - used to set positions and register the node to\n   * @param {Tiddler} protoTiddler\n   */\n  insertNode(node = {}, view, protoTiddler) {\n\n    // title might has changed after generateNewTitle()\n    node.label = this.wiki.generateNewTitle(node.label || utils.getRandomLabel());\n\n    // add to tiddler store\n    const tObj = new $tw.Tiddler(\n      { text: '' }, // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n      protoTiddler,\n      {\n        title: node.label, // force title\n        'tmap.id': null // force empty id (generated later)\n      },\n      this.wiki.getModificationFields(),\n      this.wiki.getCreationFields()\n    );\n\n    this.wiki.addTiddler(tObj);\n\n    node = this.makeNode(tObj, node);\n\n    if (ViewAbstraction.exists(view)) {\n      (new ViewAbstraction(view)).addNode(node);\n    }\n\n    return node;\n\n  }\n\n  /**\n   * Retrieve tiddlers based on the a list of corresponding ids.\n   *\n   * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids.\n   * @return {Array<TiddlerReference>} The resulting tiddlers.\n   */\n  getTiddlersByIds(nodeIds) {\n\n    // transform into a hashmap with all values being true\n    if (Array.isArray(nodeIds)) {\n      nodeIds = utils.getArrayValuesAsHashmapKeys(nodeIds);\n    } else if (nodeIds instanceof vis.DataSet) {\n      nodeIds = utils.getLookupTable(nodeIds, 'id'); // use id field as key\n    }\n\n    const result = [];\n    for (let id in nodeIds) {\n      const tRef = this.getTiddlerById(id);\n      if (tRef) {\n        result.push(tRef);\n      }\n    }\n\n    return result;\n\n  }\n}\n\n/**** Helper *******************************************************/\n\n/**\n * Returns the short symbol identifier (`&#xf2bc;` → `f206`).\n *\n * @param str FontAwesome id\n * @return {string}\n */\nconst getFAdigits = (str) => (str.length === 4 ? str : str.substr(3, 4));\n\n/**\n * Adds an icon to the specified node.\n *\n * @param {Node} node\n * @param {Object} icon\n */\nconst addNodeIcon = (node, icon) => {\n\n  if (!icon) {\n    return;\n  }\n\n  // Font Awesome style\n\n  if (icon.fa) {\n\n    node.shape = 'icon';\n    node.icon = {\n      shape: 'icon',\n      face: 'FontAwesome',\n      color: node.color,\n      code: String.fromCharCode('0x' + getFAdigits(icon.fa)),\n    };\n\n    if (node.size) {\n      node.icon.size = node.size;\n    }\n\n    return;\n  }\n\n  // TiddlyWiki stored icons\n\n  if (icon.tw) {\n\n    const imgTObj = utils.getTiddler(icon.tw);\n\n    if (!imgTObj) {\n      return;\n    }\n\n    if (imgTObj.fields['_canonical_uri']) { // image is a url address\n\n      node.image = imgTObj.fields['_canonical_uri'];\n      node.shape = 'image';\n\n    } else if (imgTObj.fields.text) {\n\n      node.image = utils.getDataUri(imgTObj);\n      node.shape = 'image';\n    }\n  }\n\n};\n\n/**\n * Garbage collector for obsolete node data.\n *\n * @param {Object<string, Node>} nodes\n * @param {ViewAbstraction|string} view\n */\nconst removeObsoleteViewData = (nodes, view) => {\n\n  if (!ViewAbstraction.exists(view) || !nodes) {\n    return;\n  }\n\n  view = new ViewAbstraction(view);\n\n  const data = view.getNodeData();\n\n  let obsoleteDataItems = 0;\n  for (let id in data) {\n    if (nodes[id] === undefined && data[id] != null) {\n      // we only set this to undefined as deletion would\n      // slow down V8, however, this necessarily requires\n      // a safeguard agains recursion: data[id] != null\n\n      data[id] = undefined;\n      obsoleteDataItems++;\n    }\n  }\n\n  if (obsoleteDataItems) {\n    $tm.logger('debug', '[Cleanup]',\n      'Removed obsolete node data:',\n      view.getLabel(), obsoleteDataItems);\n    view.saveNodeData(data);\n  }\n\n};\n\n/**\n * Sets up an edge object that is ready to be consumed by vis.\n *\n * @param {Edge} edge\n * @param {EdgeType} type\n */\nconst addStyleToEdge = (edge, type) => {\n\n  edge = Object.assign(edge, type.style);\n\n  if (utils.isTrue(type['show-label'], true)) {\n    edge.label = type.getLabel();\n  }\n\n};\n\nconst getIcon = (faIcon, twIcon) => faIcon && { fa: faIcon } || twIcon && { tw: twIcon };\n\n/*** Exports *******************************************************/\n\nexport default Adapter;\n"],"sourceRoot":"../../../../../../src/plugins"}